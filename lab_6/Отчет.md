# Отчет
##При выполнении работы я использовал следующие средства профилирования: 
cProfile, line_profiler, memory_profiler и pyheat(только в самой ранней версии, но потом отказался от использования данного средства)

Результат своей работы я бы хотел коротко изложить в данном файле-отчете.

### memory_profiler:
Оптимизация не привела к уменьшению потребления памяти (RAM), это обусловлено тем, что оно(потребление)изначально минимально и не связано с крупными структурами данных.
По результатам профилирования при помощи memory_profiler у изначального и оптимизированного кодов одинаковые результаты:
Начальная память: 83.5 MiB.(В зависимости от запуска значение менялось в пределах от 83.3 MiB до 83.7 MiB)
Максимальное потребление: 83.5 MiB.
Прирост: 0.0 MiB во время выполнения.

### cProfile:
Информация о вызовах функций оказалась весьма противоречивой:
Наблюдалось 2 ситуации:
- когда каждый код рассматриваются отдельно( файлы с соответствующим анализом я приложил в папке с результатами)
- когда оба кода вызываются и анализируются совместно(как на фото ниже)
![image](https://github.com/user-attachments/assets/d3f81521-7580-4017-baaf-dbf8553819d1)
![image](https://github.com/user-attachments/assets/623bfba2-5507-4f9b-add5-f3e776e80255)
В первом случае в зависимости от конкретного запуска время в ходе одного сеанса запуска кода было либо одинаковым, либо на 0.001 больше для оптимизированного кода,
во втором же случае ситуация была противоположна(время было либо одинаковым, либо на 0.001 больше для исходного кода)

### line_profiler:
Это то самое средство профилирования, которое демонстрирует результат моей оптимизации кода, удалось добиться сокращения общего времени выполнения 2 тестов, 
функция main не менялась, а оптимизация similar_sequences_test не привела к снижению времени выполнения
Главным такой сокращение времени достигалось благодаря замене циклов for и промежуточных измнений sum

### Ремарка 
PyPy не был задействован в данной л.р. поскольку оптимизируемый код и без повышения производительности выполняется крайне быстро
От pyheat я отказался поскольку результатирующая тепловая карта менялась от запуска к запуску очень радикально, что затрудняло поиск 
строк, которые занимают больше времени на выполнение, да и само это время было крайне малым(также при работе с кодом на 139 строк получалась каша, которую бы приходилось приближать на отдельных участках для анализа)





